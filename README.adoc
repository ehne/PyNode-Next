:doctype: book
:t_generic_text: pass:[<code class="literal">str</code>, <code class="literal">int</code> or <code class="literal">float</code>] 
:t_node_generic: pass:[<code class="literal">Node</code>, <code class="literal">str</code>, <code class="literal">int</code> or <code class="literal">float</code>]
:t_node: pass:[<code class="literal">Node</code>]
:toc: macro

++++
<p>
  <img alt="logo" src="./assets/card.png" align="center" />
</p>
++++

[discrete]
= PyNode Next

> A complete rewrite of PyNode for the modern era.

++++
<details>
<summary>Table of contents</summary>
++++

toc::[]

++++
</details>
++++


== Getting started
To get started, download the https://github.com/ehne/PyNode-Next/releases/latest[latest version of PyNode Next] and place the folder in your project's directory.

[NOTE]
====
PyNode Next requires https://github.com/algrx/algorithmx-python[AlgorithmX], so you might need to install that if you haven't done so previously. 
This can usually be done by running the following in your terminal.

[source, bash]
----
$ python3 -m pip install algorithmx
----
====

Then all you need to do is create a new python file that looks like this and you can start writing code for PyNode Next.

[source, python]
----
from pynode_next import *

def run():
    # put your python code here.
    # here is an example of what you could do:
    graph.add_node("a")
    graph.add_node("b")

    graph.add_edge("a", "b")

begin_pynode_next(run)
----

== Migrating from PyNode
PyNode Next has been designed to maintain the vast majority of all of the functions from the previous version of PyNode.

Switching to PyNode Next _should_ be as simple as replacing `from pynode.main import *` with `from pynode_next import *`. And adding a `_next` to the `begin_pynode` function call.

[cols="a,a", options="header", width="100%"]
|===
| PyNode
| PyNode Next

|
[source, python]
----
from pynode.main import *

def run()
    # code
    graph.add_node("a")

begin_pynode(run)
----

| 
[source, python]
----
from pynode_next import *

def run()
    # code
    graph.add_node("a")

begin_pynode_next(run)
----

|===

== Differences from the original PyNode
* Certain methods are strongly typed. Meaning that they only accept input of specific types. This is due to how the overloading system works, and will be documented whenever it pops up.
* Keyword arguments (that's stuff like the `id=` in `add_node(id="a")`) might be broken in some methods due to the overloading system.
* `outline` options on methods don't exist any more. Text no longer has any outlines.
* You can no longer compare nodes with other nodes like `NodeA > NodeB`. To do this now, you need to specify the priority: `NodeA.priority() > NodeB.priority()`
* The above also applies to edges.
* `graph.random()` has been drastically simplified to just take `order` and `size` arguments.
* `node.position()` has not been implemented yet. (The rendering library PyNode Next uses has a different coordinate system to that of the original PyNode)

= Documentation

== `graph`

=== `graph.add_node(node)`
Adds `node` to the graph. Will raise an error if that node object has been added to the graph before.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `node` | {t_node}
|===

=== `graph.add_node(id)`
Adds a node to the graph with the `id` and `value` set to `id`.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `id` | {t_generic_text}
|===

=== `graph.add_node(id, value)`
Adds a node to the graph with the `id` and `value` set to their corresponding arguments.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `id` | {t_generic_text}
| `value` | {t_generic_text}
|===

=== `graph.remove_node(node)`
Removes the specified node from the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `node` | {t_node_generic}
|===

=== `graph.node(id)`
Returns the `Node` object of the node with the specified `id`. Raises a `NodeDoesntExistError` if that node could not be found in the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `id` | {t_generic_text}
|===

=== `graph.node(node)`
Returns the `Node` object of the `Node` object given to it as long as that node is in the graph. Raises a `NodeDoesntExistError` if that node could not be found in the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `node` | {t_node}
|===

=== `graph.nodes()`
Returns a list of all the nodes currently in the graph as `Node` objects.

=== `graph.add_edge(source, target, weight=None, directed=False)`
Adds an edge between the `source` and `target` nodes. To make the edge directed, set `directed` to `True`. `weight` sets the label of the edge.

WARNING: This is one of the methods that is a little annoying with keyword arguments. If you are going to set `directed`, you need to make sure that you *also* set `weight`. Otherwise, the overloader will raise an error.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `source` | {t_node_generic}
| `target` | {t_node_generic}
| `weight` | `None`, `bool`, {t_generic_text}
| `directed` | `bool`
|===

=== `graph.add_edge(edge)`
Adds the `Edge` object specified to the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `edge` | `Edge`
|===

=== `graph.remove_edge(nodeA, nodeB, directed=False)`
Removes the edge(s) between `nodeA` and `nodeB` from the graph. If `directed` is set, only edges starting at `nodeA` will be removed.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `nodeA` | {t_node_generic}
| `nodeB` | {t_node_generic}
| `directed` | `bool`
|===

=== `graph.remove_edge(edge)`
Removes the `Edge` object specified from the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `edge` | `Edge`
|===

=== `graph.has_node(node)`
Checks if a given `node` exists in the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `node` | {t_node_generic}
|===

=== `graph.has_edge(edge)`
Checks if a given `edge` exists in the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `edge` | `Edge`
|===

=== `graph.add_all(elements)`
Adds all `Node` and/or `Edge` objects in a list to the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `elements` | A list (iterable) containing `Node` and/or `Edge` objects.
|===

=== `graph.remove_all(elements)`
Removes all `Node` and/or `Edge` objects in a list from the graph.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `elements` | A list (iterable) containing `Node` and/or `Edge` objects.
|===

=== `graph.adjacent(nodeA, nodeB, directed=False)`
Checks if `nodeA` and `nodeB` are adjacent. If `directed` is set, then the edge must start from `nodeA`.

[cols="a,a", width="100%", options="header"]
|===
| Argument | Accepted Types
| `nodeA` | {t_node_generic}
| `nodeB` | {t_node_generic}
| `directed` | `bool`
|===